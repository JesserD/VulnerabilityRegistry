using Application.Vulnerabilities;
using AutoFixture;
using Domain;
using FluentAssertions;
using Moq;
using UnitTests.Application.Common;

namespace UnitTests.Application.Vulnerabilities;

public class EditTestSuite : HandlerTestSuite
{
    private readonly Edit.Handler _sut;

    public EditTestSuite()
    {
        _sut = new Edit.Handler(_mockVulnerabilityRepository.Object, _mockMapper.Object);
    }
    public static IEnumerable<object[]> InvalidVulnerabilities()
    {
        yield return new object[] { $"vulnerability--{Guid.NewGuid()}", null, "There must be an object in the body" };
        yield return new object[] { $"vulnerability--{Guid.NewGuid()}", _fixture.Build<UpdatedVulnerability>().With(v => v.SpecVersion, "1.1").Create(), "SpecVersion must be either 2.0 or 2.1" };
        yield return new object[] { string.Empty, _fixture.Build<UpdatedVulnerability>().With(v => v.SpecVersion, "2.1").Create(), "Id must not be empty." };
        yield return new object[] { "invalidId", _fixture.Build<UpdatedVulnerability>().With(v => v.SpecVersion, "2.1").Create(), "Id must follow the format 'vulnerability--<UUID>'." };
    }

    [Theory]
    [MemberData(nameof(InvalidVulnerabilities))]
    public async void Handle_ShouldReturnFailureResult_WhenInValidInput(string id, UpdatedVulnerability? input, string expectedErrorMsg)
    {
        var editCommand = new Edit.Command {Id = id, UpdatedVulnerability = input };

        var result = await _sut.Handle(editCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Contain(expectedErrorMsg);
    }

    [Fact]
    public async void Handle_ShouldReturnFailureResult_WhenVulnerabilityDoesNotExist()
    {
        var updatedVulnerability = _fixture.Build<UpdatedVulnerability>()
            .With(v => v.SpecVersion, "2.1")
            .Create();
        var editCommand = new Edit.Command { Id = $"vulnerability--{Guid.NewGuid()}", UpdatedVulnerability = updatedVulnerability };
        _mockVulnerabilityRepository.Setup(v => v.GetById(editCommand.Id)).ReturnsAsync(null as Vulnerability);

        var result = await _sut.Handle(editCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be($"No vulnerability with the given Id '{editCommand.Id}' to update");
    }

    [Fact]
    public async void Handle_ShouldReturnFailureResult_WhenRepoFailsToUpdate()
    {
        var updatedVulnerability = _fixture.Build<UpdatedVulnerability>()
            .With(v => v.SpecVersion, "2.1")
            .Create();
        var editCommand = new Edit.Command { Id = $"vulnerability--{Guid.NewGuid()}", UpdatedVulnerability = updatedVulnerability };
        _mockVulnerabilityRepository.Setup(v => v.GetById(editCommand.Id)).ReturnsAsync(_fixture.Create<Vulnerability>());
        _mockVulnerabilityRepository.Setup(v => v.Update(editCommand.Id, It.IsAny<Vulnerability>())).ReturnsAsync(false);

        var result = await _sut.Handle(editCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be("Failed to update vulnerability");
    }

    [Fact]
    public async void Handle_ShouldReturnSuccessResult_WhenWhenValidUpdatedVulnerabilityIsPassed()
    {
        var updatedVulnerability = _fixture.Build<UpdatedVulnerability>()
            .With(v => v.SpecVersion, "2.1")
            .Create();
        var editCommand = new Edit.Command { Id = $"vulnerability--{Guid.NewGuid()}", UpdatedVulnerability = updatedVulnerability };
        _mockVulnerabilityRepository.Setup(v => v.GetById(editCommand.Id)).ReturnsAsync(_fixture.Create<Vulnerability>());
        _mockVulnerabilityRepository.Setup(v => v.Update(editCommand.Id, It.IsAny<Vulnerability>())).ReturnsAsync(true);

        var result = await _sut.Handle(editCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeTrue();
    }

}
