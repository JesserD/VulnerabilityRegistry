using Application.Vulnerabilities;
using AutoFixture;
using Domain;
using FluentAssertions;
using Moq;
using UnitTests.Application.Common;

namespace UnitTests.Application.Vulnerabilities;

public class CreateTestSuite : HandlerTestSuite
{
    private readonly Create.Handler _sut;

    public CreateTestSuite()
    {
        _sut = new Create.Handler(_mockVulnerabilityRepository.Object);
    }

    public static IEnumerable<object[]> InvalidVulnerabilities()
    {
        yield return new object[] { _fixture.Build<Vulnerability>().With(v => v.Type, "Breach").Create(), "Type must be 'vulnerability" };
        yield return new object[] { _fixture.Build<Vulnerability>().With(v => v.SpecVersion, "1.1").Create(), "SpecVersion must be either 2.0 or 2.1" };
        yield return new object[] { _fixture.Build<Vulnerability>().With(v => v.Id, "invalid Id").Create(), "Id must follow the format 'vulnerability--<UUID>'." };
        yield return new object[] { _fixture.Build<Vulnerability>().With(v => v.Created, DateTime.MinValue).Create(), "Created must not be empty" };
        yield return new object[] { _fixture.Build<Vulnerability>().With(v => v.Modified, DateTime.MinValue).Create(), "Modified must not be empty" };
    }

    [Theory]
    [MemberData(nameof(InvalidVulnerabilities))]
    public async void Handle_ShouldReturnFailureResult_WhenInValidInput(Vulnerability input, string expectedErrorMsg)
    {
        var createCommand = new Create.Command { Vulnerability = input };

        var result = await _sut.Handle(createCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Contain(expectedErrorMsg);
    }

    [Fact]
    public async void Handle_ShouldReturnFailureResult_WhenVulnerabilityAlreadyExists()
    {
        var vulnerability = _fixture.Build<Vulnerability>()
            .With(v => v.Id, $"vulnerability--{Guid.NewGuid()}")
            .With(v => v.SpecVersion, "2.1")
            .With(v => v.Type, "vulnerability")
            .Create();
        var createCommand = new Create.Command { Vulnerability = vulnerability };
        _mockVulnerabilityRepository.Setup(v => v.GetById(vulnerability.Id)).ReturnsAsync(vulnerability);

        var result = await _sut.Handle(createCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be("There is already a vulnerability with this Id");
    }

    [Fact]
    public async void Handle_ShouldReturnFailureResult_WhenRepoFailsToAdd()
    {
        var vulnerability = _fixture.Build<Vulnerability>()
            .With(v => v.Id, $"vulnerability--{Guid.NewGuid()}")
            .With(v => v.SpecVersion, "2.1")
            .With(v => v.Type, "vulnerability")
            .Create();
        var createCommand = new Create.Command { Vulnerability = vulnerability };
        _mockVulnerabilityRepository.Setup(v => v.GetById(vulnerability.Id)).ReturnsAsync(null as Vulnerability);
        _mockVulnerabilityRepository.Setup(v => v.Add(vulnerability)).ReturnsAsync(false);

        var result = await _sut.Handle(createCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be("Failed to create vulnerability");
    }

    [Fact]
    public async void Handle_ShouldReturnSuccessResult_WhenValidVulnerabilityIsPassed()
    {
        var vulnerability = _fixture.Build<Vulnerability>()
            .With(v => v.Id, $"vulnerability--{Guid.NewGuid()}")
            .With(v => v.SpecVersion, "2.1")
            .With(v => v.Type, "vulnerability")
            .Create();
        var createCommand = new Create.Command { Vulnerability = vulnerability };
        _mockVulnerabilityRepository.Setup(v => v.GetById(vulnerability.Id)).ReturnsAsync(null as Vulnerability);
        _mockVulnerabilityRepository.Setup(v => v.Add(vulnerability)).ReturnsAsync(true);

        var result = await _sut.Handle(createCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeTrue();
    }
}
