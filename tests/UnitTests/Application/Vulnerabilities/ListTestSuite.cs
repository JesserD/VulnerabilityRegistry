using Application.Core;
using Application.Vulnerabilities;
using AutoFixture;
using Domain;
using FluentAssertions;
using Moq;
using UnitTests.Application.Common;

namespace UnitTests.Application.Vulnerabilities;

public class ListTestSuite : HandlerTestSuite
{
    private readonly Mock<IPagedListFactory> _mockPagedListFactory;
    private readonly List.Handler _sut;

    public ListTestSuite()
    {
        _mockPagedListFactory = new Mock<IPagedListFactory>();
        _sut = new List.Handler(_mockVulnerabilityRepository.Object, _mockMapper.Object, _mockPagedListFactory.Object);

    }

    [Fact]
    public async void Handle_ShouldReturnVulnerabilities()
    {
        var vulnerabilities = _fixture.CreateMany<Vulnerability>().AsQueryable();
        var pagedVulnerabilities = new PagedList<VulnerabilityDto>(
            [
                _fixture.Build<VulnerabilityDto>().With(v => v.Name, "SQL Injection (SQLi)").Create(),
            ], 3, 1, 2);

        _mockVulnerabilityRepository.Setup(r => r.GetAll()).Returns(vulnerabilities);
        _mockPagedListFactory.Setup(f => f.CreateAsync(It.IsAny<IQueryable<VulnerabilityDto>>(), It.IsAny<int>(), It.IsAny<int>()))
            .ReturnsAsync(pagedVulnerabilities);

        var ListQuery = new List.Query() { Params = new VulnerabilityParams() };

        var result = await _sut.Handle(ListQuery, _mockCancellationToken);

        result.IsSuccess.Should().BeTrue();
        result.Value.Should().BeSameAs(pagedVulnerabilities);
    }
}
