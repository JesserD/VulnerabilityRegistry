using Application.Core;
using Application.Vulnerabilities;
using AutoFixture;
using Domain;
using FluentAssertions;
using Moq;
using UnitTests.Application.Common;

namespace UnitTests.Application.Vulnerabilities;

public class DetailsTestSuite: HandlerTestSuite
{
    private readonly Details.Handler _sut;

    public DetailsTestSuite()
    {
        _sut = new Details.Handler(_mockVulnerabilityRepository.Object, _mockMapper.Object);
    }

    [Theory]
    [InlineData("invalidId")]
    [InlineData("vulnerability--grfew2-2231-321")]
    [InlineData("3cbb1725-e61f-4e60-aa2b-0bf69bf4411d")]
    public async void Handle_ShouldReturnFailureResult_WhenIdIsInvalid(string id)
    {
        var detailsQuery = _fixture.Build<Details.Query>().With(q => q.Id, id).Create();
        var expected = Result<VulnerabilityDto>.Failure("Id must follow the format 'vulnerability--<UUID>'.");

        var result = await _sut.Handle(detailsQuery, _mockCancellationToken);

        result.Should().BeEquivalentTo(expected);
    }
    
    [Fact]
    public async void Handle_ShouldReturnSuccessResult_WhenIdIsValid()
    {
        var detailsQuery = _fixture.Build<Details.Query>().With(q => q.Id, $"vulnerability--{Guid.NewGuid()}").Create();
        var vulnerability = _fixture.Create<Vulnerability>();
        var expected = _fixture.Create<VulnerabilityDto>();
        _mockMapper.Setup(m => m.Map<VulnerabilityDto>(vulnerability)).Returns(expected);
        _mockVulnerabilityRepository.Setup(repo => repo.GetById(detailsQuery.Id)).ReturnsAsync(vulnerability);

        var result = await _sut.Handle(detailsQuery, _mockCancellationToken);

        result.IsSuccess.Should().BeTrue();
        result.Value.Should().BeEquivalentTo(expected);
    }

}
