
using Application.Vulnerabilities;
using AutoFixture;
using Domain;
using FluentAssertions;
using Moq;
using UnitTests.Application.Common;

namespace UnitTests.Application.Vulnerabilities;

public class DeleteTestSuite : HandlerTestSuite
{
    private readonly Delete.Handler _sut;

    public DeleteTestSuite()
    {
        _sut = new Delete.Handler(_mockVulnerabilityRepository.Object);
    }

    [Theory]
    [InlineData("", "Id must not be empty.")]
    [InlineData("invalidId", "Id must follow the format 'vulnerability--<UUID>'.")]
    public async void Handle_ShouldReturnFailureResult_WhenInValidIdIsPassed(string id, string expectedErrorMsg)
    {
        var deleteCommand = new Delete.Command { Id = id };

        var result = await _sut.Handle(deleteCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Contain(expectedErrorMsg);
    }

    [Fact]
    public async void Handle_ShouldReturnFailureResult_WhenVulnerabilityDoesNotExist()
    {
        var updatedVulnerability = _fixture.Build<UpdatedVulnerability>()
            .With(v => v.SpecVersion, "2.1")
            .Create();
        var deleteCommand = new Delete.Command { Id = $"vulnerability--{Guid.NewGuid()}" };
        _mockVulnerabilityRepository.Setup(v => v.GetById(deleteCommand.Id)).ReturnsAsync(null as Vulnerability);

        var result = await _sut.Handle(deleteCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be($"No vulnerability with the given Id '{deleteCommand.Id}' to delete");
    }

    [Fact]
    public async void Handle_ShouldReturnFailureResult_WhenRepoFailsToDelete()
    {
        var deleteVulnerability = _fixture.Build<Vulnerability>()
            .With(v => v.Id, $"vulnerability--{Guid.NewGuid()}")
            .Create();
        var deleteCommand = new Delete.Command { Id = deleteVulnerability.Id };
        _mockVulnerabilityRepository.Setup(v => v.GetById(deleteCommand.Id)).ReturnsAsync(deleteVulnerability);
        _mockVulnerabilityRepository.Setup(v => v.Delete(deleteVulnerability)).ReturnsAsync(false);

        var result = await _sut.Handle(deleteCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeFalse();
        result.Error.Should().Be("Failed to delete vulnerability");
    }

    [Fact]
    public async void Handle_ShouldReturnSuccessResult_WhenWhenValidIdIsPassed()
    {
        var deleteVulnerability = _fixture.Build<Vulnerability>()
            .With(v => v.Id, $"vulnerability--{Guid.NewGuid()}")
            .Create();
        var deleteCommand = new Delete.Command { Id = deleteVulnerability.Id };
        _mockVulnerabilityRepository.Setup(v => v.GetById(deleteCommand.Id)).ReturnsAsync(deleteVulnerability);
        _mockVulnerabilityRepository.Setup(v => v.Delete(deleteVulnerability)).ReturnsAsync(true);

        var result = await _sut.Handle(deleteCommand, _mockCancellationToken);

        result.IsSuccess.Should().BeTrue();
    }

}
